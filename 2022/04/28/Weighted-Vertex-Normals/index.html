<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.1.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="Weighted Vertex Normals 原文链接 3DSMAX PluginA popular MaxScript plugin for 3DSMAX (previously hosted on GitHub) is now available here. IntroductionWhen rendering 3D triangle mesh geometry, vertex normal">
<meta name="keywords" content="normal">
<meta property="og:type" content="article">
<meta property="og:title" content="Weighted Vertex Normals">
<meta property="og:url" content="https://lumieru.github.io/2022/04/28/Weighted-Vertex-Normals/index.html">
<meta property="og:site_name" content="Lumieru的知识库">
<meta property="og:description" content="Weighted Vertex Normals 原文链接 3DSMAX PluginA popular MaxScript plugin for 3DSMAX (previously hosted on GitHub) is now available here. IntroductionWhen rendering 3D triangle mesh geometry, vertex normal">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://blog.sensedevil.com/image/vertnormals1.png">
<meta property="og:image" content="http://blog.sensedevil.com/image/vertnormals2.png">
<meta property="og:image" content="http://blog.sensedevil.com/image/vertnormals3.png">
<meta property="og:updated_time" content="2022-04-28T02:17:02.958Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Weighted Vertex Normals">
<meta name="twitter:description" content="Weighted Vertex Normals 原文链接 3DSMAX PluginA popular MaxScript plugin for 3DSMAX (previously hosted on GitHub) is now available here. IntroductionWhen rendering 3D triangle mesh geometry, vertex normal">
<meta name="twitter:image" content="http://blog.sensedevil.com/image/vertnormals1.png">





  
  
  <link rel="canonical" href="https://lumieru.github.io/2022/04/28/Weighted-Vertex-Normals/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Weighted Vertex Normals | Lumieru的知识库</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Lumieru的知识库</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://lumieru.github.io/2022/04/28/Weighted-Vertex-Normals/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lumieru">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lumieru的知识库">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Weighted Vertex Normals

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2022-04-28 09:49:04 / 修改时间：10:17:02" itemprop="dateCreated datePublished" datetime="2022-04-28T09:49:04+08:00">2022-04-28</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Graphics/" itemprop="url" rel="index"><span itemprop="name">Graphics</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Weighted-Vertex-Normals"><a href="#Weighted-Vertex-Normals" class="headerlink" title="Weighted Vertex Normals"></a>Weighted Vertex Normals</h1><hr>
<p><a href="https://www.bytehazard.com/articles/vertnorm.html" target="_blank" rel="noopener">原文链接</a></p>
<h3 id="3DSMAX-Plugin"><a href="#3DSMAX-Plugin" class="headerlink" title="3DSMAX Plugin"></a>3DSMAX Plugin</h3><p>A popular MaxScript plugin for 3DSMAX (previously hosted on GitHub) is now available <a href="https://www.bytehazard.com/articles/wnormals.html" target="_blank" rel="noopener">here</a>.</p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>When rendering 3D triangle mesh geometry, vertex normal vectors (‘<em>normals</em>‘) need to be computed either in real-time or at design-time, to achieve proper lighting of curved surfaces. There are a few ways to do this, however, the most commonly used method has significant flaws. This article illustrates two of those problems, and proposes a practical and robust solution.</p>
<p>The assumption is made that the reader is familiar with <a href="http://en.wikipedia.org/wiki/Surface_normal" target="_blank" rel="noopener">surface normal vectors</a> and their <a href="http://en.wikipedia.org/wiki/Phong_shading" target="_blank" rel="noopener">application</a> in 3D graphics rendering.</p>
<h3 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h3><p>Geometry may have ‘hard edges’ (sometimes called ‘sharp edges’), in which case multiple vertex normals may lie at the same vertex position. This is covered here for completeness sake only; the proposed enhancements do not have any effect on the presence or appearance of hard edges.</p>
<p>The included code uses per-polygon smoothing-groups (most popular in 3D content authoring software) to achieve hard edges, though this can be substituted by any (algorithmic) criteria (e.g. angle between surface normals greater than _x_ degrees).</p>
<p>Hard edges can also be created by duplicating vertices (for optimal rendering on modern graphics hardware), but for simplicity we’ll assume there are no duplicate vertices present in the model.</p>
<p>Also note that the pseudo-code presented herein is far from optimal, and can be optimized in many ways.</p>
<a id="more"></a>
<h3 id="Terminology"><a href="#Terminology" class="headerlink" title="Terminology"></a>Terminology</h3><table>
<thead>
<tr>
<th>Parameter</th>
<th>Desciption</th>
</tr>
</thead>
<tbody>
<tr>
<td>face</td>
<td>A triangle consisting of three vertices.</td>
</tr>
<tr>
<td>polygon</td>
<td>A planar surface consisting of three or more vertices.</td>
</tr>
<tr>
<td>facet normal</td>
<td>The normal vector of the plane in which a face or polygon lies.</td>
</tr>
<tr>
<td>vertex normal</td>
<td>A normal at one of the three vertices of a face. There may be more than one vertex normal per vertex position (hard edges).</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="The-Problem"><a href="#The-Problem" class="headerlink" title="The Problem"></a>The Problem</h2><p>When vertex normals are generated, it generally goes like this:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> each face A in mesh</span><br><span class="line">&#123;</span><br><span class="line"> n = face A facet normal</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// loop through all vertices of face A</span></span><br><span class="line"> <span class="keyword">for</span> each vert in face A</span><br><span class="line"> (</span><br><span class="line">  <span class="keyword">for</span> each face B in mesh</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="comment">// ignore self</span></span><br><span class="line">   <span class="keyword">if</span> face A == face B then skip</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// criteria for hard-edges</span></span><br><span class="line">   <span class="keyword">if</span> face A <span class="keyword">and</span> B smoothing groups match &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// accumulate normal</span></span><br><span class="line">    <span class="keyword">if</span> faces share at least one vert &#123;</span><br><span class="line">     n += (face B facet normal)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// normalize vertex normal</span></span><br><span class="line">  vn = normalize(n)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In English: vertex _v_ will have a normal _n_ which is the average of the combined facet normals of all connected polygons. In most situations this will look fine. But consider the situation below:</p>
<p><img src="http://blog.sensedevil.com/image/vertnormals1.png" alt="vertnormals1"></p>
<p>In this case the triangles that make up the thin beveled edges of the box will ‘claim’ much of the normal orientation. This causes the ‘rounded’ shading on the large flat sides of the box (problem #1).</p>
<p>This is then made worse because two corners of those large sides contribute 2x the facet normal (2 triangles touch the vertex), while the other two corners contribute only 1x (one triangle touches the vertex). This results into a discontinuity (the diagonal artifact in the above illustration) when shaded (problem #2).</p>
<p>A poor solution would be to simply align the normals to the axii of the faces when such geometry is generated (difficult to preserve) and/or to have an artist correct it by hand (labor intensive). However, we are interested in a generic solution that works for arbitrary geometry constructed from triangles (known as ‘<em>triangle soup</em>‘) and _n_-sided polygons alike, requiring no artist intervention.</p>
<hr>
<h2 id="Surface-Area-Weights"><a href="#Surface-Area-Weights" class="headerlink" title="Surface Area Weights"></a>Surface Area Weights</h2><p>The solution is to determine the influence of each face in it’s contribution to the vertex normal. The obvious way to do that is by using the surface area of each face as ‘weight’. Small polygons will have little influence, large polygons have large influence.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> each face A in mesh</span><br><span class="line">&#123;</span><br><span class="line"> n = face A facet normal</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// loop through all vertices in face A</span></span><br><span class="line"> <span class="keyword">for</span> each vert in face A</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">for</span> each face B in mesh</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="comment">// ignore self</span></span><br><span class="line">   <span class="keyword">if</span> face A == face B then skip</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// criteria for hard-edges</span></span><br><span class="line">   <span class="keyword">if</span> face A <span class="keyword">and</span> B smoothing groups match &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// accumulate normal</span></span><br><span class="line">    <span class="keyword">if</span> faces share at least one vert &#123;</span><br><span class="line">     n += (face B facet normal) * (face B surface area) <span class="comment">// multiply by area</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// normalize vertex normal</span></span><br><span class="line">  vn = normalize(n)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>As you can see, we simply multiply the facet normal by the triangle area when we accumulate it. Since we are already normalizing the resulting vector, we don’t have to do anything else. Behold:</p>
<p><img src="http://blog.sensedevil.com/image/vertnormals2.png" alt="vertnormals2"></p>
<p>That looks much more pleasing. The beveled edges do actually still have have a slight influence over the larger sides of the box, but this is hardly noticeable in most situations (and in other cases even desirable).</p>
<hr>
<h2 id="Angle-Weights"><a href="#Angle-Weights" class="headerlink" title="Angle Weights"></a>Angle Weights</h2><p>While the above technique does fix the most visible problems, there’s another issue that is worthwhile to consider. This problem is most noticeable on low-polygon cylindrical shapes:</p>
<p><img src="http://blog.sensedevil.com/image/vertnormals3.png" alt="vertnormals3"></p>
<p>It may be hard to spot, but if you look closely you will notice a subtle shading discontinuity between vertex _A_ and vertex _D_. The three faces that influence vertex _A_, are faces _t_, _u_ and _v_. Although both faces _U_ and _V_ belong to the same polygon (_UV_), the facet normal of that polygon contributes twice. This causes the averaged vertex normal _A_ to point slightly to our right.<br>At vertex _C_ the opposite happens, there _st_ pulls the normal to our left. The result being that the two vertex normals diverge when they should be parallel.</p>
<p>We could potentially determine which faces lie in the same plane and skip accumulating coinciding facet normals, but this works only in a small number of situations.</p>
<p>A robust solution is to calculate the angle of the corners of the polygons, and use that as additional weight (just like surface area) at that corners vertex. In the above figure, at vertex _A_, the combined angles of the two corners of faces _u_ and _v_ will equal the corner angle of face _t_.</p>
<p>In pseudo code, that becomes:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> each face A in mesh</span><br><span class="line">&#123;</span><br><span class="line"> n = face A facet normal</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// loop through all vertices in face A</span></span><br><span class="line"> <span class="keyword">for</span> each vert in face A</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">for</span> each face B in mesh</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="comment">// ignore self</span></span><br><span class="line">   <span class="keyword">if</span> face A == face B then skip</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// criteria for hard-edges</span></span><br><span class="line">   <span class="keyword">if</span> face A <span class="keyword">and</span> B smoothing groups match &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// accumulate normal</span></span><br><span class="line">    <span class="comment">// v1, v2, v3 are the vertices of face A</span></span><br><span class="line">    <span class="keyword">if</span> face B shares v1 &#123;</span><br><span class="line">     angle = angle_between_vectors( v1 - v2 , v1 - v3 )</span><br><span class="line">     n += (face B facet normal) * (face B surface area) * angle <span class="comment">// multiply by angle</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> face B shares v2 &#123;</span><br><span class="line">     angle = angle_between_vectors( v2 - v1 , v2 - v3 )</span><br><span class="line">     n += (face B facet normal) * (face B surface area) * angle <span class="comment">// multiply by angle</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> face B shares v3 &#123;</span><br><span class="line">     angle = angle_between_vectors( v3 - v1 , v3 - v2 )</span><br><span class="line">     n += (face B facet normal) * (face B surface area) * angle <span class="comment">// multiply by angle</span></span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// normalize vertex normal</span></span><br><span class="line">  vn = normalize(n)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Here, <em>angle</em> is the angle in radians (or degrees*) between the two vectors of the two line segments that touch each of the three vertices in a face.</p>
<p>* Because we normalize the end result, the angle may be computed/stored as either radians or degrees. Only the ratio between neighboring triangle features (surface area, corner angle) contributes as weight, so the choice of angular units does not matter.</p>
<hr>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>Weighted vertex normals improve the appearance of virtually all geometry, and is generally superior to the traditional non-weighted average. It works because the undesired shading artifacts are displaced from large (highly visible) polygons to their smaller neighbors (less visible), and thereby guarantees improved visuals in virtually all common situations.</p>
<p>Since vertex normal generation is most often a design-time process, there is no impact on performance, unless the normals are re-calculated from scratch in realtime.</p>
<p>Even though tangent space normal mapping is widely used nowadays, tangent vector use and computation requires the presence of vertex normals, and here these enhancements also improve visual quality. Tangent and bi-tangent vectors should be accumulated and weighted in parallel to vertex normals before orthogonalization for best quality.</p>
<p>Additionally, weighted vertex normals also allow for faux-rounded edges (smooth shaded beveled edges) without significantly increasing the polygon count, and can greatly reduce distortions of specular reflection highlights and environment mapped reflective/refractive surfaces.</p>
<hr>
<p>Author: Martijn Buijs<br>Created on: 2007-12-23<br>Last modified: 2018-10-18<br>Contact: martijn AT bytehazard DOT com</p>
<hr>
<h2 id="附录：3ds-Max脚本"><a href="#附录：3ds-Max脚本" class="headerlink" title="附录：3ds Max脚本"></a>附录：3ds Max脚本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line">-- WEIGHTEDNORMALS.MS</span><br><span class="line"></span><br><span class="line">-- Computes Weighted Vertex Normals</span><br><span class="line">-- by Martijn Buijs, 2014</span><br><span class="line">-- www.bytehazard.com</span><br><span class="line"></span><br><span class="line">-- 3DSMAX bugs encountered:</span><br><span class="line">-- 1) .modifiers[#Edit_Normals] doesn&apos;t work on renamed modifiers for no</span><br><span class="line">--     apparant reason</span><br><span class="line">-- 2) We can only ever modify the topmost Edit_Normals modifier, even if we</span><br><span class="line">--    properly access it through its handle. So if there&apos;s another Edit_Normals</span><br><span class="line">--    modifier on the stack, we add a new modifier, so the user won&apos;t have his</span><br><span class="line">--    changes overwritten.</span><br><span class="line">-- 3) During testing, the script twice crashed on some geometry lacking</span><br><span class="line">--    smoothing groups. Unable to reproduce.</span><br><span class="line"></span><br><span class="line">global wnmodname = &quot;Weighted Normals&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- returns angle between two vectors</span><br><span class="line">fn AngleBetweenVectors v1 v2 =</span><br><span class="line">(</span><br><span class="line"> return (acos (dot (normalize v1) (normalize v2) ) )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- get weighted normals modifier</span><br><span class="line">fn wnGetModifier obj =</span><br><span class="line">(</span><br><span class="line"> for i=1 to obj.modifiers.count do</span><br><span class="line"> (</span><br><span class="line">  local mf = obj.modifiers[i]</span><br><span class="line">  if (classof mf) == Edit_Normals do</span><br><span class="line">  (</span><br><span class="line">   if (mf.name == wnmodname) then (</span><br><span class="line">    return mf</span><br><span class="line">   ) else (</span><br><span class="line">    return undefined</span><br><span class="line">   )</span><br><span class="line">  )</span><br><span class="line"> )</span><br><span class="line"> return undefined</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- generates weighted normals</span><br><span class="line">fn GenWeightedNormals obj =</span><br><span class="line">(</span><br><span class="line"> -- filter</span><br><span class="line"> if (superClassOf obj) != GeometryClass do return false</span><br><span class="line"> </span><br><span class="line"> -- add mesh modifier</span><br><span class="line"> if (classOf obj) != Editable_Mesh do</span><br><span class="line"> (</span><br><span class="line">  addModifier obj (Edit_Mesh())</span><br><span class="line"> )</span><br><span class="line"> </span><br><span class="line"> -- detect existing modifier</span><br><span class="line"> local mf = wnGetModifier obj</span><br><span class="line"> </span><br><span class="line"> -- modifier not found, create one</span><br><span class="line"> if mf == undefined do</span><br><span class="line"> (</span><br><span class="line">  addModifier obj (Edit_Normals())</span><br><span class="line">  mf = obj.modifiers[#Edit_Normals]</span><br><span class="line">  mf.name = wnmodname</span><br><span class="line"> )</span><br><span class="line"> </span><br><span class="line"> -- workaround for 3dsmax bug</span><br><span class="line"> select obj</span><br><span class="line"> max modify mode</span><br><span class="line">  </span><br><span class="line"> -- build face area array</span><br><span class="line"> local facearea = #()</span><br><span class="line"> facearea.count = obj.numFaces</span><br><span class="line"> for i=1 to obj.numFaces do</span><br><span class="line"> (</span><br><span class="line">  facearea[i] = (meshop.getFaceArea obj i)</span><br><span class="line"> )</span><br><span class="line"> </span><br><span class="line"> -- build face angle array</span><br><span class="line"> local faceangle = #()</span><br><span class="line"> faceangle.count = obj.numFaces</span><br><span class="line"> for i=1 to obj.numFaces do</span><br><span class="line"> (</span><br><span class="line">  local f = getFace obj i</span><br><span class="line">  local v1 = getVert obj f[1]</span><br><span class="line">  local v2 = getVert obj f[2]</span><br><span class="line">  local v3 = getVert obj f[3]</span><br><span class="line">  local a1 = AngleBetweenVectors (v2-v1) (v3-v1) -- todo: optimize</span><br><span class="line">  local a2 = AngleBetweenVectors (v1-v2) (v3-v2)</span><br><span class="line">  local a3 = AngleBetweenVectors (v1-v3) (v2-v3)</span><br><span class="line">  faceangle[i] = [a1,a2,a3]</span><br><span class="line"> )</span><br><span class="line"> </span><br><span class="line"> -- get number of normals</span><br><span class="line"> local normNum = mf.GetNumNormals()</span><br><span class="line"> </span><br><span class="line"> -- allocate array</span><br><span class="line"> local norms = #()</span><br><span class="line"> norms.count = normNum</span><br><span class="line"> for i=1 to normNum do</span><br><span class="line"> (</span><br><span class="line">  norms[i] = [0,0,0]</span><br><span class="line"> )</span><br><span class="line"> </span><br><span class="line"> -- loop faces</span><br><span class="line"> for i=1 to obj.numFaces do</span><br><span class="line"> (</span><br><span class="line">  -- get face normal</span><br><span class="line">  in coordsys local n = getFaceNormal obj i</span><br><span class="line">  </span><br><span class="line">  -- accumulate</span><br><span class="line">  for j=1 to 3 do</span><br><span class="line">  (</span><br><span class="line">   local id = mf.GetNormalID i j</span><br><span class="line">   norms[id] = norms[id] + (n * facearea[i] * faceangle[i][j])</span><br><span class="line">  )</span><br><span class="line"> )</span><br><span class="line"> </span><br><span class="line"> -- set normals</span><br><span class="line"> for i=1 to normNum do</span><br><span class="line"> (</span><br><span class="line">  -- make explicit</span><br><span class="line">  mf.SetNormalExplicit i explicit:true</span><br><span class="line">  </span><br><span class="line">  -- set normal vector</span><br><span class="line">  mf.SetNormal i (normalize norms[i])</span><br><span class="line"> )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--- GUI ------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- close existing floater</span><br><span class="line">if WeightedNormals != undefined do</span><br><span class="line">(</span><br><span class="line"> closeRolloutFloater WeightedNormals</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">-- create floater</span><br><span class="line">WeightedNormals = newRolloutFloater &quot;Weighted Normals&quot; 180 150</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- generate rollout</span><br><span class="line">rollout rWNGenerate &quot;Weighted Normals&quot;</span><br><span class="line">(</span><br><span class="line"> button cmdCreate &quot;Generate&quot; width:140</span><br><span class="line"> </span><br><span class="line"> on cmdCreate pressed do</span><br><span class="line"> (</span><br><span class="line">  -- copy selection (can&apos;t copy arrays in 3dsmax)</span><br><span class="line">  local sel = #()</span><br><span class="line">  for i=1 to selection.count do</span><br><span class="line">  (</span><br><span class="line">   sel[i] = selection[i]</span><br><span class="line">  )</span><br><span class="line">  </span><br><span class="line">  -- create selection list</span><br><span class="line">  for i=1 to sel.count do</span><br><span class="line">  (</span><br><span class="line">   GenWeightedNormals sel[i]</span><br><span class="line">  )</span><br><span class="line">  </span><br><span class="line">  -- restore selection</span><br><span class="line">  selection = sel</span><br><span class="line"> )</span><br><span class="line">)</span><br><span class="line">addRollout rWNGenerate WeightedNormals</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- about rollout</span><br><span class="line">rollout rWNAbout &quot;About&quot;</span><br><span class="line">(</span><br><span class="line"> label lab1 &quot;Weighted Normals 1.0.0&quot;</span><br><span class="line"> label lab2 &quot;by Martijn Buijs&quot;</span><br><span class="line"> label lab3 &quot;www.bytehazard.com&quot;</span><br><span class="line">)</span><br><span class="line">addRollout rWNAbout WeightedNormals</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- END OF FILE</span><br></pre></td></tr></table></figure>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/normal/" rel="tag"><i class="fa fa-tag"></i> normal</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/09/03/Unity动画系统原理/" rel="next" title="Unity动画系统原理">
                <i class="fa fa-chevron-left"></i> Unity动画系统原理
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Lumieru</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">45</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">8</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">17</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Weighted-Vertex-Normals"><span class="nav-number">1.</span> <span class="nav-text">Weighted Vertex Normals</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3DSMAX-Plugin"><span class="nav-number">1.0.1.</span> <span class="nav-text">3DSMAX Plugin</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Introduction"><span class="nav-number">1.1.</span> <span class="nav-text">Introduction</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Notes"><span class="nav-number">1.1.1.</span> <span class="nav-text">Notes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Terminology"><span class="nav-number">1.1.2.</span> <span class="nav-text">Terminology</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#The-Problem"><span class="nav-number">1.2.</span> <span class="nav-text">The Problem</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Surface-Area-Weights"><span class="nav-number">1.3.</span> <span class="nav-text">Surface Area Weights</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Angle-Weights"><span class="nav-number">1.4.</span> <span class="nav-text">Angle Weights</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Conclusion"><span class="nav-number">1.5.</span> <span class="nav-text">Conclusion</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#附录：3ds-Max脚本"><span class="nav-number">1.6.</span> <span class="nav-text">附录：3ds Max脚本</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lumieru</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.1.1</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.1"></script>

  <script src="/js/motion.js?v=7.1.1"></script>



  
  


  <script src="/js/affix.js?v=7.1.1"></script>

  <script src="/js/schemes/pisces.js?v=7.1.1"></script>



  
  <script src="/js/scrollspy.js?v=7.1.1"></script>
<script src="/js/post-details.js?v=7.1.1"></script>



  


  <script src="/js/next-boot.js?v=7.1.1"></script>


  

  

  

  


  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

  

  

  

  

  

  
<script>
  $('.highlight').each(function(i, e) {
    var $wrap = $('<div>').addClass('highlight-wrap');
    $(e).after($wrap);
    $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function(e) {
      var code = $(this).parent().find('.code').find('.line').map(function(i, e) {
        return $(e).text();
      }).toArray().join('\n');
      var ta = document.createElement('textarea');
      var yPosition = window.pageYOffset || document.documentElement.scrollTop;
      ta.style.top = yPosition + 'px'; // Prevent page scroll
      ta.style.position = 'absolute';
      ta.style.opacity = '0';
      ta.readOnly = true;
      ta.value = code;
      document.body.appendChild(ta);
      ta.select();
      ta.setSelectionRange(0, code.length);
      ta.readOnly = false;
      var result = document.execCommand('copy');
      
        if (result) $(this).text('复制成功');
        else $(this).text('复制失败');
      
      ta.blur(); // For iOS
      $(this).blur();
    })).on('mouseleave', function(e) {
      var $b = $(this).find('.copy-btn');
      setTimeout(function() {
        $b.text('复制');
      }, 300);
    }).append(e);
  })
</script>


  

  

</body>
</html>
